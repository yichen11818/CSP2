# CSP2 技术设计文档

> Counter-Strike 2 Server Panel - CS2服务器管理面板

**版本**: v0.1.0  
**更新时间**: 2025-10-26  
**作者**: CSP2 开发团队

---

## 📋 目录

1. [项目概述](#项目概述)
2. [技术栈](#技术栈)
3. [系统架构](#系统架构)
4. [核心模块设计](#核心模块设计)
5. [数据模型](#数据模型)
6. [Provider扩展机制](#Provider扩展机制)
7. [安全性考虑](#安全性考虑)
8. [性能优化](#性能优化)

---

## 1. 项目概述

### 1.1 项目定位

CSP2 是一个面向 **CS2 服务器管理员** 的开源桌面管理工具，类似于Minecraft的PCL2启动器。

### 1.2 核心功能

- ✅ CS2专用服务器的启动、停止、重启管理
- ✅ 实时日志查看和命令行交互
- ✅ 插件框架管理（Metamod、CounterStrikeSharp等）
- ✅ 插件市场（浏览、安装、更新、卸载插件）
- ✅ 服务器配置管理
- ✅ 多服务器实例管理
- ✅ 社区扩展支持（Provider机制）

### 1.3 设计原则

1. **模块化**: 使用Provider模式，平台、框架、扩展完全解耦
2. **可扩展性**: 社区可以轻松添加新平台、新框架支持
3. **用户友好**: 简洁美观的UI，类似PCL2的使用体验
4. **开源透明**: MIT协议，欢迎社区贡献

### 1.4 目标用户

- CS2服务器管理员
- 社区服务器运营者
- 插件开发者
- 游戏社区

---

## 2. 技术栈

### 2.1 开发环境

```
操作系统: Windows 10/11 (MVP), Linux (V2)
开发工具: Visual Studio 2022
.NET版本: .NET 8.0
语言版本: C# 12
```

### 2.2 框架和库

| 技术 | 版本 | 用途 |
|------|------|------|
| WPF | .NET 8.0 | UI框架（MVP阶段） |
| Avalonia UI | 11.x | 跨平台UI（V2迁移） |
| CommunityToolkit.Mvvm | 8.x | MVVM辅助库 |
| Microsoft.Extensions.* | 8.x | 依赖注入、配置、日志 |
| Serilog | 3.x | 日志框架 |
| System.Text.Json | 8.x | JSON序列化 |
| System.IO.Compression | 8.x | ZIP解压 |
| HttpClient + Polly | 8.x + 8.x | HTTP请求和重试策略 |

### 2.3 工具链

- **SteamCMD**: 下载和更新CS2服务器文件
- **GitHub API**: 获取插件Release信息
- **GitHub Actions**: CI/CD自动化构建

---

## 3. 系统架构

### 3.1 总体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      Presentation Layer                     │
│                    (WPF / Avalonia UI)                      │
│                                                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ Server   │  │ Plugin   │  │ Log      │  │ Settings │  │
│  │ View     │  │ Market   │  │ Console  │  │ View     │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└───────────────────────────┬─────────────────────────────────┘
                            │ MVVM Binding
┌───────────────────────────▼─────────────────────────────────┐
│                      Application Layer                      │
│                    (ViewModels + Commands)                  │
│                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │ ServerVM     │  │ PluginMarket │  │ SettingsVM   │    │
│  │              │  │ VM           │  │              │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
└───────────────────────────┬─────────────────────────────────┘
                            │ Service Layer
┌───────────────────────────▼─────────────────────────────────┐
│                        Business Layer                       │
│                     (Core Services)                         │
│                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │ Server       │  │ Plugin       │  │ Provider     │    │
│  │ Manager      │  │ Manager      │  │ Registry     │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
│                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │ SteamCMD     │  │ Repository   │  │ Config       │    │
│  │ Service      │  │ Service      │  │ Manager      │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
└───────────────────────────┬─────────────────────────────────┘
                            │ Provider Interface
┌───────────────────────────▼─────────────────────────────────┐
│                      Provider Layer                         │
│                   (Platform & Framework)                    │
│                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │ Windows      │  │ Linux        │  │ Docker       │    │
│  │ Provider     │  │ Provider     │  │ Provider     │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
│                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │ CSS          │  │ Metamod      │  │ Swiftly      │    │
│  │ Provider     │  │ Provider     │  │ Provider     │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 分层职责

#### **Presentation Layer (表示层)**
- 负责UI渲染和用户交互
- 使用MVVM模式，View和ViewModel分离
- 不包含业务逻辑

#### **Application Layer (应用层)**
- ViewModel处理UI逻辑
- 命令绑定和数据绑定
- 调用Business Layer的服务

#### **Business Layer (业务层)**
- 核心业务逻辑
- 服务器管理、插件管理等
- 不依赖具体的UI框架

#### **Provider Layer (提供者层)**
- 抽象平台和框架差异
- 可插拔的Provider实现
- 社区可扩展

---

## 4. 核心模块设计

### 4.1 模块划分

#### **CSP2.Core (核心库)**
- 定义所有抽象接口
- 数据模型
- 核心服务实现
- Provider注册机制

#### **CSP2.Providers (提供者实现)**
- Windows平台支持
- CounterStrikeSharp框架支持
- Metamod框架支持
- （未来：Linux、Swiftly等）

#### **CSP2.Desktop (桌面应用)**
- WPF界面
- ViewModels
- 应用程序入口
- 资源文件

#### **CSP2.SDK (扩展SDK)**
- 供社区开发扩展的SDK
- 插件接口定义
- 示例代码

---

### 4.2 ServerManager (服务器管理器)

**职责**: 管理CS2服务器的生命周期

```csharp
public interface IServerManager
{
    // 获取所有服务器
    Task<List<Server>> GetServersAsync();
    
    // 添加服务器
    Task<Server> AddServerAsync(ServerConfig config);
    
    // 启动服务器
    Task<ServerProcess> StartServerAsync(string serverId);
    
    // 停止服务器
    Task StopServerAsync(string serverId, bool force = false);
    
    // 重启服务器
    Task RestartServerAsync(string serverId);
    
    // 发送命令
    Task SendCommandAsync(string serverId, string command);
    
    // 事件：日志输出
    event EventHandler<LogReceivedEventArgs> LogReceived;
    
    // 事件：服务器状态变化
    event EventHandler<ServerStatusChangedEventArgs> StatusChanged;
}
```

**实现要点**:
- 使用`IPlatformProvider`启动进程
- 异步读取标准输出作为日志
- 支持标准输入发送命令
- 状态管理：停止、启动中、运行中、停止中、崩溃

---

### 4.3 PluginManager (插件管理器)

**职责**: 管理插件的安装、更新、卸载

```csharp
public interface IPluginManager
{
    // 获取可用插件列表（从仓库）
    Task<List<PluginInfo>> GetAvailablePluginsAsync();
    
    // 获取已安装插件
    Task<List<InstalledPlugin>> GetInstalledPluginsAsync(string serverId);
    
    // 安装插件
    Task<InstallResult> InstallPluginAsync(string serverId, string pluginId, 
        IProgress<InstallProgress>? progress = null);
    
    // 更新插件
    Task<InstallResult> UpdatePluginAsync(string serverId, string pluginId);
    
    // 卸载插件
    Task<bool> UninstallPluginAsync(string serverId, string pluginId);
    
    // 启用/禁用插件
    Task<bool> SetPluginEnabledAsync(string serverId, string pluginId, bool enabled);
}
```

**实现要点**:
- 委托给对应的`IFrameworkProvider`执行
- 处理依赖关系（如CSS依赖Metamod）
- 支持进度报告
- 错误处理和回滚

---

### 4.4 ProviderRegistry (提供者注册中心)

**职责**: 管理所有Provider的注册和获取

```csharp
public class ProviderRegistry
{
    // 注册平台提供者
    void RegisterPlatformProvider(IPlatformProvider provider);
    
    // 注册框架提供者
    void RegisterFrameworkProvider(IFrameworkProvider provider);
    
    // 自动选择最佳平台Provider
    IPlatformProvider GetBestPlatformProvider();
    
    // 获取指定框架Provider
    IFrameworkProvider? GetFrameworkProvider(string frameworkId);
    
    // 列出所有可用框架
    List<FrameworkInfo> GetAvailableFrameworks();
    
    // 从目录加载Provider（运行时插件）
    Task LoadProvidersFromDirectoryAsync(string directory);
}
```

---

### 4.5 SteamCmdService (SteamCMD服务)

**职责**: 下载和更新CS2服务器文件

```csharp
public interface ISteamCmdService
{
    // 检查SteamCMD是否已安装
    Task<bool> IsSteamCmdInstalledAsync();
    
    // 下载SteamCMD（如果需要）
    Task<bool> DownloadSteamCmdAsync(IProgress<DownloadProgress>? progress = null);
    
    // 安装/更新CS2服务器
    Task<bool> InstallOrUpdateServerAsync(string installPath, 
        IProgress<InstallProgress>? progress = null);
    
    // 验证服务器文件完整性
    Task<bool> ValidateServerFilesAsync(string installPath);
}
```

**实现要点**:
- 用户可以选择：
  - 使用已有的CS2安装（游戏本身就能当服务器）
  - 通过SteamCMD下载专用服务器
- 支持断点续传
- 进度回调

---

### 4.6 PluginRepositoryService (插件仓库服务)

**职责**: 从GitHub仓库获取插件列表

```csharp
public interface IPluginRepositoryService
{
    // 获取插件清单（带缓存）
    Task<PluginManifest> GetManifestAsync(bool forceRefresh = false);
    
    // 搜索插件
    Task<List<PluginInfo>> SearchPluginsAsync(string keyword);
    
    // 按分类过滤
    Task<List<PluginInfo>> GetPluginsByCategoryAsync(string category);
    
    // 获取插件详情
    Task<PluginInfo?> GetPluginDetailsAsync(string pluginId);
    
    // 检查插件更新
    Task<Dictionary<string, string>> CheckUpdatesAsync(List<InstalledPlugin> installed);
}
```

**数据来源**:
- ~~第一阶段：本地JSON文件（模拟数据）~~ ✅ 已完成
- ✅ **当前实现**：从GitHub仓库读取manifest.json
- ✅ 多级缓存机制，离线可用

**GitHub插件源架构** (2025-10-27更新):

CSP2现已实现完整的GitHub插件源系统，插件元数据托管在独立仓库：

```
csp2-plugin-repository (GitHub)
    ↓ CDN加速 (jsDelivr)
    ↓ HTTP GET
CSP2.Core.Services.PluginRepositoryService
    ↓ 缓存到本地
data/plugins-cache.json
    ↓ 读取
PluginMarketViewModel (UI)
```

**多级降级策略**:
1. **内存缓存**: 1小时内直接返回，无网络请求
2. **远程拉取**: 从CDN拉取最新manifest.json
3. **本地缓存**: 网络失败时使用本地缓存文件
4. **内置默认**: 完全离线时使用内置插件列表

**CDN端点**:
```
主要: https://cdn.jsdelivr.net/gh/your-org/csp2-plugin-repository@main/manifest.json
备用: https://raw.githubusercontent.com/your-org/csp2-plugin-repository/main/manifest.json
```

**自动化更新**:
- GitHub Actions每6小时自动拉取插件最新版本
- 支持社区PR提交新插件
- 自动验证JSON Schema和下载链接
- 详见: [csp2-plugin-repository](https://github.com/your-org/csp2-plugin-repository)

---

## 5. 数据模型

### 5.1 Server (服务器实体)

```csharp
public class Server
{
    public string Id { get; set; }              // 唯一标识（GUID）
    public string Name { get; set; }            // 服务器名称
    public string InstallPath { get; set; }     // 安装路径
    public ServerStatus Status { get; set; }    // 当前状态
    public ServerConfig Config { get; set; }    // 配置信息
    public DateTime CreatedAt { get; set; }
    public DateTime? LastStartedAt { get; set; }
}

public enum ServerStatus
{
    Stopped,        // 已停止
    Starting,       // 启动中
    Running,        // 运行中
    Stopping,       // 停止中
    Crashed         // 崩溃
}

public class ServerConfig
{
    // 基础配置
    public string IpAddress { get; set; } = "0.0.0.0";
    public int Port { get; set; } = 27015;
    public string Map { get; set; } = "de_dust2";
    public string MapGroup { get; set; } = "mg_active";
    public int MaxPlayers { get; set; } = 10;
    public int GameType { get; set; } = 0;
    public int GameMode { get; set; } = 1;
    public int TickRate { get; set; } = 128;
    
    // 服务器身份
    public string? ServerName { get; set; }
    public string? ServerPassword { get; set; }
    public string? RconPassword { get; set; }
    public string? SteamToken { get; set; }
    
    // 网络设置
    public bool IsLanMode { get; set; } = false;
    public bool InsecureMode { get; set; } = false;
    
    // 性能优化
    public bool EnableConsole { get; set; } = true;
    public string ProcessPriority { get; set; } = "normal";
    public int? MaxFps { get; set; }
    public int? ThreadCount { get; set; }
    public bool DisableHltv { get; set; } = false;
    
    // 游戏规则
    public bool EnableCheats { get; set; } = false;
    public int BotQuota { get; set; } = 0;
    public int BotDifficulty { get; set; } = 2;
    public int? KickIdleTime { get; set; }
    
    // 日志设置
    public bool EnableLogging { get; set; } = true;
    public bool ConsoleLogToFile { get; set; } = false;
    public bool LogEcho { get; set; } = true;
    
    // 自定义参数
    public Dictionary<string, string> CustomArgs { get; set; } = new();
}
```

---

### 5.2 Plugin (插件信息)

```csharp
public class PluginInfo
{
    public string Id { get; set; }              // 唯一标识（小写）
    public string Name { get; set; }            // 显示名称
    public string Author { get; set; }
    public string Description { get; set; }     // 英文描述
    public string? DescriptionZh { get; set; }  // 中文描述（可选）
    
    public string Framework { get; set; }       // counterstrikesharp, metamod, etc.
    public string[] Dependencies { get; set; } = [];
    public string Category { get; set; }        // gameplay, admin, utility, etc.
    public string[] Tags { get; set; } = [];
    
    public string Version { get; set; }
    public string DownloadUrl { get; set; }
    public long DownloadSize { get; set; }
    
    public SourceInfo Source { get; set; }
    public InstallationInfo Installation { get; set; }
    public LinksInfo Links { get; set; }
    
    public bool Verified { get; set; }          // 是否验证过
    public bool Featured { get; set; }          // 是否推荐
    public int Downloads { get; set; }          // 下载次数
    public float Rating { get; set; }           // 评分
}

public class InstalledPlugin
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string Version { get; set; }
    public string Framework { get; set; }
    public bool Enabled { get; set; }
    public string InstallPath { get; set; }
    public DateTime InstalledAt { get; set; }
}
```

---

### 5.3 FrameworkInfo (框架信息)

```csharp
public class FrameworkInfo
{
    public string Id { get; set; }              // counterstrikesharp, metamod
    public string Name { get; set; }            // CounterStrikeSharp
    public string ShortName { get; set; }       // CSS
    public string Description { get; set; }
    
    public string[] Dependencies { get; set; } = [];
    
    public string InstallPath { get; set; }     // 相对于服务器根目录
    public string PluginPath { get; set; }
    public string ConfigPath { get; set; }
    
    public string[] SupportedPlatforms { get; set; } = [];
    
    public string RepositoryUrl { get; set; }
    public string DocumentationUrl { get; set; }
    
    public string? InstalledVersion { get; set; }
    public string? LatestVersion { get; set; }
}
```

---

## 6. Provider扩展机制

### 6.1 设计思想

使用**策略模式 + 提供者模式**，将不同平台、不同框架的实现解耦。

**核心接口**:
- `IPlatformProvider`: 抽象操作系统差异（Windows、Linux）
- `IFrameworkProvider`: 抽象插件框架差异（CSS、Metamod、Swiftly）
- `IExtensionProvider`: 抽象面板扩展功能（RCON、备份、监控）

### 6.2 Provider生命周期

```
1. 启动阶段：
   - 扫描providers/目录
   - 加载所有Provider DLL
   - 注册到ProviderRegistry

2. 使用阶段：
   - 根据需求获取对应Provider
   - 调用Provider方法执行操作

3. 扩展阶段：
   - 用户下载第三方Provider
   - 放入providers/目录
   - 重启应用自动加载
```

### 6.3 Provider开发指南

社区开发者只需：
1. 引用`CSP2.Core`（接口定义）
2. 实现对应接口
3. 添加元数据特性
4. 编译成DLL
5. 分享给用户

**示例**:
```csharp
// 社区开发者实现Linux支持
public class LinuxPlatformProvider : IPlatformProvider
{
    public ProviderMetadata Metadata => new()
    {
        Id = "linux",
        Name = "Linux",
        Version = "1.0.0",
        Author = "Community Developer",
        Description = "Linux平台支持"
    };
    
    public bool IsSupported()
    {
        return RuntimeInformation.IsOSPlatform(OSPlatform.Linux);
    }
    
    // ... 实现其他方法
}
```

---

## 7. 安全性考虑

### 7.1 潜在风险

1. **任意代码执行**: 运行时加载第三方Provider DLL
2. **路径遍历**: 用户输入的安装路径
3. **命令注入**: 构造服务器启动参数
4. **敏感信息泄露**: Steam Token等

### 7.2 缓解措施

1. **Provider签名验证**（V2）: 只加载签名的DLL
2. **路径验证**: 检查路径是否包含危险字符
3. **参数转义**: 使用`ProcessStartInfo`的参数数组而非字符串
4. **配置加密**: 敏感配置使用DPAPI加密存储
5. **权限最小化**: 不要求管理员权限

---

## 8. 性能优化

### 8.1 异步操作

所有耗时操作使用`async/await`:
- 文件下载
- 进程启动/停止
- 日志读取
- 网络请求

### 8.2 缓存策略

- **插件列表**: 本地缓存1小时，过期后重新拉取
- **框架版本**: 缓存最新版本信息
- **服务器配置**: 内存缓存，变更时持久化

### 8.3 UI响应性

- 长时间操作显示进度条
- 使用`IProgress<T>`报告进度
- 日志显示使用虚拟化列表（超过1000行时）
- 使用`Dispatcher`/`SynchronizationContext`更新UI

### 8.4 UI线程管理（重要）

**已知问题修复 - UI卡死问题**:

在WPF应用中，所有UI更新必须在UI线程执行，但长时间操作会导致界面卡死。以下是关键最佳实践：

1. **同步阻塞操作必须异步化**
   ```csharp
   // ❌ 错误: 同步操作阻塞UI线程
   ZipFile.ExtractToDirectory(zipPath, installPath);
   
   // ✅ 正确: 在后台线程执行
   await Task.Run(() => ZipFile.ExtractToDirectory(zipPath, installPath));
   ```

2. **Progress回调使用BeginInvoke而不是Invoke**
   ```csharp
   // ❌ 错误: Invoke会阻塞后台线程
   Dispatcher.Invoke(() => { Progress = value; });
   
   // ✅ 正确: BeginInvoke是异步的
   Dispatcher.BeginInvoke(() => { Progress = value; });
   ```

3. **MessageBox在异步方法中的正确使用**
   ```csharp
   // ✅ 正确: 通过Dispatcher异步调用
   var result = await Dispatcher.InvokeAsync(() => 
       MessageBox.Show("提示", "标题", MessageBoxButton.YesNo));
   ```

4. **避免在同步方法中等待异步操作**
   ```csharp
   // ❌ 错误: 容易导致死锁
   var result = asyncMethod().GetAwaiter().GetResult();
   
   // ✅ 正确: 在新任务上下文执行
   var task = Task.Run(async () => await asyncMethod());
   var result = task.GetAwaiter().GetResult();
   ```

### 8.5 异常处理和错误报告系统

**改进的错误处理机制**（2025-10-26更新）:

CSP2实现了完善的三层异常处理机制，确保用户体验和错误诊断：

1. **全局异常捕获**
   - `AppDomain.UnhandledException`: 捕获应用程序域级别的未处理异常
   - `DispatcherUnhandledException`: 捕获UI线程的未处理异常
   - `TaskScheduler.UnobservedTaskException`: 捕获异步任务中未观察到的异常

2. **ErrorDialog - 友好的错误对话框**
   ```csharp
   // 使用方法
   ErrorDialog.Show(
       errorMessage: "简短的错误描述",
       exception: ex,
       subtitle: "操作已停止"
   );
   ```
   
   **特性**：
   - 显示简短错误消息和详细堆栈信息
   - 支持文本选择和复制（Ctrl+C）
   - "复制全部"按钮一键复制完整错误报告
   - 包含环境信息（操作系统、.NET版本等）
   - **不会立即退出程序**，允许用户复制错误信息后决定操作

3. **异常处理策略**
   - **UI线程异常**: 显示ErrorDialog，标记`e.Handled = true`，程序继续运行
   - **后台任务异常**: 调用`e.SetObserved()`，显示ErrorDialog
   - **域级异常**: 显示ErrorDialog后记录日志
   - 所有异常都会同时记录到Serilog日志系统和DebugLogger

4. **错误停止机制**
   - 异常发生时立即停止当前操作（设置Handled/SetObserved）
   - 防止连锁错误（如XAML解析错误不会疯狂重复）
   - 保持应用程序稳定，给用户选择权

**示例：处理下载错误**
```csharp
try
{
    await _downloadManager.DownloadAsync(url, path, progress);
}
catch (Exception ex)
{
    Log.Error(ex, "下载失败");
    DebugLogger.Error("Download", "下载文件失败", ex);
    
    // 显示友好的错误对话框
    ErrorDialog.Show(
        errorMessage: $"下载失败：{ex.Message}",
        exception: ex,
        subtitle: "下载操作已停止"
    );
    
    // 清理部分下载的文件
    CleanupPartialDownload(path);
}
```

---

## 9. 调试和日志系统

### 9.1 Debug模式

CSP2支持Debug模式，提供更详细的调试信息：

**启用方式**:
1. **命令行参数**: `CSP2.Desktop.exe --debug`
2. **环境变量**: 设置 `CSP2_DEBUG=true`
3. **VS Code**: 使用 "CSP2 Desktop (Debug Mode)" 启动配置

**Debug模式特性**:
- 自动启用Debug级别日志记录
- 侧栏显示"Debug控制台"菜单项
- 实时查看应用程序级别的调试日志
- 独立于服务器日志的应用日志系统

### 9.2 双日志系统架构

CSP2使用双日志系统：

1. **应用日志 (DebugLogger)** - Debug控制台
   - 显示应用程序本身的操作日志
   - 包括：用户操作、服务调用、状态变化、错误异常
   - 支持过滤：Debug/Info/Warning/Error
   - 支持导出到文件

2. **服务器日志 (LogConsole)** - 日志控制台  
   - 显示CS2服务器进程的输出
   - 实时捕获服务器stdout/stderr
   - 支持发送命令到服务器

### 9.3 DebugLogger使用示例

```csharp
// 在任何地方记录调试日志
DebugLogger.Debug("Category", "详细调试信息");
DebugLogger.Info("Category", "重要信息");
DebugLogger.Warning("Category", "警告信息");
DebugLogger.Error("Category", "错误信息", exception);

// 检查是否为Debug模式
if (DebugLogger.IsDebugMode)
{
    // 只在Debug模式下执行的代码
}
```

### 9.4 日志级别策略

| 模式 | Serilog级别 | DebugLogger | 用途 |
|------|------------|-------------|------|
| Release | Information | 仅Info及以上 | 生产环境 |
| Debug | Debug | 全部级别 | 开发调试 |

### 9.5 日志文件位置

- **文件路径**: `<应用目录>/logs/csp2-YYYY-MM-DD.log`
- **滚动策略**: 每天一个新文件
- **保留策略**: 保留30天
- **大小限制**: 单文件最大10MB

### 9.6 VS Code调试配置

项目包含 `.vscode/launch.json` 和 `.vscode/tasks.json`:

```json
{
  "name": "CSP2 Desktop (Debug Mode)",
  "type": "coreclr",
  "request": "launch",
  "args": ["--debug"],
  "env": { "CSP2_DEBUG": "true" }
}
```

**使用步骤**:
1. 在VS Code中打开项目
2. 按 F5 或选择"运行和调试"
3. 选择 "CSP2 Desktop (Debug Mode)"
4. 应用将以Debug模式启动，侧栏显示Debug控制台

---

## 10. 统一下载管理系统

**更新时间**: 2025-10-25

CSP2实现了统一的下载管理系统，所有下载任务（服务器文件、插件、框架、更新等）都通过全局下载管理器进行管理。

### 10.1 下载管理架构

```
用户操作 (安装服务器/插件)
    ↓
创建服务器/插件配置
    ↓
添加到DownloadManager (后台任务)
    ↓
立即返回主页面 (非阻塞)
    ↓
后台下载进行中
    ↓
用户可在下载管理页面查看进度
```

### 10.2 核心特性

1. **非阻塞操作**
   - 用户点击"安装服务器"后，立即返回服务器列表
   - 服务器配置已创建，显示在列表中
   - 下载任务在后台静默进行

2. **统一入口**
   - 侧边栏导航：下载管理页面（全屏查看）
   - 下载悬浮球：在任何页面显示，点击跳转到下载管理
   - 实时徽章：显示当前活动下载数量

3. **多任务并行**
   - 支持同时下载多个任务
   - 每个任务独立进度追踪
   - 支持暂停、取消、移除操作

### 10.3 下载管理页面功能

**位置**: 主窗口 → 下载管理（侧边栏）

**显示内容**:
- 任务名称和描述
- 实时进度条（百分比）
- 任务状态（等待/下载中/完成/失败/已取消）
- 创建时间
- 操作按钮（取消、移除）

**状态说明**:
- **等待中** (⏳): 任务已创建，等待开始
- **下载中** (⬇️): 正在下载，显示实时进度
- **完成** (✅): 下载成功完成
- **失败** (❌): 下载出错，可查看错误信息
- **暂停** (⏸️): 任务已暂停（未来支持）
- **已取消** (🚫): 用户取消下载

### 10.4 下载悬浮球

**位置**: 主窗口右下角（状态栏上方）

**显示逻辑**:
- 有活动下载时自动显示
- 无下载任务时自动隐藏

**显示内容**:
- 下载图标 (⬇️)
- 活动下载任务数量徽章
- 发光动效提示

**交互**:
- 点击：导航到下载管理页面
- 悬停：放大效果

### 10.5 服务器安装流程改进

**旧流程**（阻塞）:
```
步骤1: 选择方式 → 步骤2: 填写信息 → 步骤3: 等待下载完成 → 返回主页
                                        ↑ 用户被卡在这里
```

**新流程**（非阻塞）:
```
步骤1: 选择方式 → 步骤2: 填写信息 → 立即返回主页 ✓
                                  ↓
                            后台下载（异步）
                                  ↓
                         下载管理页面显示进度
```

**优势**:
- ✅ 用户体验流畅，无需等待
- ✅ 可以继续其他操作（查看日志、管理插件等）
- ✅ 支持批量安装（多个服务器同时下载）
- ✅ 统一的进度监控界面

### 10.6 实现细节

**后台任务管理**:
```csharp
// 服务器安装流程
var server = await _serverManager.AddServerWithoutValidationAsync(name, path, config);
_onInstallComplete?.Invoke(server); // 立即返回主页

// 后台下载任务
_ = Task.Run(async () =>
{
    await _steamCmdService.InstallOrUpdateServerAsync(path, false, null);
    // DownloadManager会自动管理任务状态
});
```

**事件同步**:
- `DownloadManager.TaskAdded`: 新任务添加时更新UI
- `DownloadManager.TaskUpdated`: 进度更新时刷新UI
- `DownloadManager.TaskCompleted`: 任务完成时通知用户
- `DownloadManager.TaskFailed`: 任务失败时显示错误

**SteamCMD 进度解析** (2025-10-25更新):

根据 [SteamCMD 官方文档](https://developer.valvesoftware.com/wiki/Zh/SteamCMD)，SteamCMD 输出以下格式的进度信息：

```
Update state (0x61) downloading, progress: 12.34 (1234567890 / 10000000000)
Update state (0x81) verifying, progress: 56.78 (...)
Success! App '730' fully installed.
```

CSP2 实现了精确的进度解析：

1. **精确进度提取**: 从 `progress: X.XX` 中提取百分比
2. **状态识别**: 
   - `downloading` → 正在下载 CS2 服务器文件
   - `verifying` → 正在验证文件完整性
   - `preallocating` → 正在预分配磁盘空间
   - `validating` → 正在验证现有文件
3. **进度映射**: 将0-100%映射到30-100%（前30%为SteamCMD安装）
4. **节流优化**: 限制更新频率为500ms，避免UI刷新过快
5. **备用节点**: 自动切换到中国内地节点（`media.st.dl.bscstorage.net`）

**示例输出解析**:
```csharp
// 输入: "Update state (0x61) downloading, progress: 45.67 (12345678 / 27890123)"
// 解析: 进度 = 45.67%
// 映射: 30 + (45.67 * 0.7) = 61.97%
// 消息: "正在下载 CS2 服务器文件... 45.67%"
```

### 10.7 用户使用指南

**安装服务器**:
1. 点击"安装服务器"
2. 选择下载方式（SteamCMD或现有安装）
3. 填写服务器名称和配置
4. 点击"确认添加"
5. 立即返回服务器列表（服务器已添加）
6. 点击悬浮球或侧边栏"下载管理"查看下载进度
7. 下载完成后，服务器即可启动

**监控下载进度**:
- 方式1: 点击右下角悬浮球（有下载时显示）
- 方式2: 侧边栏 → 下载管理
- 方式3: 悬浮球徽章显示活动任务数量

**管理下载任务**:
- 查看所有下载任务（活动和历史）
- 取消正在进行的下载
- 移除已完成或失败的任务
- 一键清空所有已完成任务

---

## 11. 国际化 (i18n) 支持

**更新时间**: 2025-10-25

CSP2 现已全面支持国际化，当前支持简体中文和英文两种语言。

### 11.1 架构设计

- **资源文件系统**: 使用 .NET 的 .resx 资源文件管理翻译
- **LocalizationService**: 管理语言切换和文化设置
- **LocalizationHelper**: 提供 XAML 绑定支持
- **动态切换**: 用户可在运行时切换语言，无需重启

### 11.2 使用方法

**在 C# 代码中**:
```csharp
using CSP2.Desktop.Resources;

// 直接访问
string title = Strings.App_Title;

// 格式化字符串
string msg = string.Format(Strings.Download_Completed, taskName);
```

**在 XAML 中**:
```xaml
<Window.Resources>
    <helpers:LocalizationHelper x:Key="Loc"/>
</Window.Resources>

<TextBlock Text="{Binding Source={StaticResource Loc}, Path=App_Title}"/>
```

**切换语言**:
用户可在"设置"页面的"外观"部分切换语言。

### 11.3 添加新语言

1. 创建新的资源文件 `Strings.[语言代码].resx`
2. 更新 `LocalizationService.GetSupportedLanguages()`
3. 翻译所有字符串

详细说明请参考 `05-i18n国际化使用指南.md`。

---

## 12. 服务器启动参数配置系统

**更新时间**: 2025-10-26

CSP2 提供了完善的服务器启动参数配置系统，通过友好的UI界面让用户轻松配置各种服务器启动选项。

### 12.1 配置分类

服务器配置按功能分为三大类，使用Tab页签组织：

#### **Tab 1: 基本配置**
- **网络配置**: IP地址、端口
- **游戏配置**: 初始地图、最大玩家数、Tick Rate、地图组

#### **Tab 2: 服务器身份**
- **显示信息**: 服务器在浏览器中的显示名称
- **认证信息**: Steam Token（公开服务器必需）
- **安全信息**: 服务器密码、RCON密码

#### **Tab 3: 高级选项**
- **网络选项**: 局域网模式、禁用VAC
- **性能选项**: 进程优先级、最大FPS、线程数、禁用HLTV、启用控制台
- **游戏规则**: BOT数量、BOT难度、踢出闲置时间、启用作弊
- **日志选项**: 启用日志、控制台日志写入文件、日志回显

### 12.2 启动参数说明

| 参数类别 | 参数名称 | 说明 | 默认值 |
|---------|---------|------|--------|
| **基础配置** |
| | IP地址 | 服务器绑定的IP地址 | 0.0.0.0 (所有网卡) |
| | 端口 | 服务器监听端口 | 27015 |
| | 初始地图 | 服务器启动时加载的地图 | de_dust2 |
| | 地图组 | 地图轮换组 | mg_active |
| | 最大玩家数 | 服务器允许的最大玩家数 | 10 |
| | Tick Rate | 服务器刷新率(64/128) | 128 |
| **服务器身份** |
| | 服务器名称 | 在浏览器中显示的名称 | (可选) |
| | Steam Token | 公开服务器令牌 | (可选) |
| | 服务器密码 | 进入服务器的密码 | (可选) |
| | RCON密码 | 远程管理密码 | (可选) |
| **网络设置** |
| | 局域网模式 | 是否为局域网服务器 | 否 |
| | 禁用VAC | 禁用反外挂系统 | 否 |
| **性能优化** |
| | 进程优先级 | CPU优先级(低/普通/高) | 普通 |
| | 最大FPS | 服务器最大帧率 | (无限制) |
| | 线程数 | 工作线程数 | (自动) |
| | 禁用HLTV | 禁用观战系统 | 否 |
| | 启用控制台 | 显示控制台窗口 | 是 |
| **游戏规则** |
| | BOT数量 | AI机器人数量 | 0 |
| | BOT难度 | 机器人难度(0-3) | 2 (困难) |
| | 踢出闲置时间 | 自动踢出闲置玩家的时间 | (不踢出) |
| | 启用作弊 | 允许作弊命令 | 否 |
| **日志设置** |
| | 启用日志 | 记录服务器日志 | 是 |
| | 控制台日志写入 | 控制台输出保存到文件 | 否 |
| | 日志回显 | 在控制台显示日志 | 是 |

### 12.3 用户体验改进

1. **分类展示**: 使用Tab页签将配置项按类别组织，避免界面杂乱
2. **工具提示**: 每个配置项都有详细的Tooltip说明
3. **默认值**: 所有配置项都有合理的默认值，新手用户可直接使用
4. **输入验证**: 对关键参数进行实时验证，防止错误配置
5. **可选参数**: 高级选项标记为可选，留空时不会生成对应的启动参数

### 12.4 国际化支持

所有配置项的标签、提示信息都完全支持国际化：
- **中文**: 完整的中文界面和说明
- **英文**: 完整的英文界面和说明
- 用户可在设置中一键切换语言

### 12.5 扩展性

配置系统设计考虑了未来的扩展需求：
- **CustomArgs**: 支持添加任意自定义启动参数
- **Provider机制**: 不同平台可以扩展特定的启动参数
- **配置模板**: 未来可支持保存和加载配置模板

---

## 13. Workshop 地图历史管理

**更新时间**: 2025-10-26

CSP2 实现了完整的 Workshop 地图历史管理功能，从 cs2servergui 项目移植并改进。

### 13.1 功能概述

Workshop 地图历史管理系统自动记录服务器加载的 Workshop 创意工坊地图，包括：

- **自动记录**: 检测 `host_workshop_map` 命令并自动记录
- **Steam API 集成**: 获取地图名称、作者、描述等详细信息
- **预览图下载**: 自动下载并缓存地图预览图
- **加载统计**: 记录地图加载次数和最后加载时间
- **多服务器支持**: 每个服务器独立的地图历史

### 13.2 技术架构

```
用户执行命令: host_workshop_map 123456
    ↓
LogConsoleViewModel 检测命令
    ↓
ISteamWorkshopService 解析 Workshop ID
    ↓
调用 Steam API 获取地图信息
    ↓
下载地图预览图到本地
    ↓
IMapHistoryService 保存到 JSON 文件
    ↓
MapHistoryViewModel 展示历史记录
```

### 13.3 核心组件

#### **ISteamWorkshopService** - Steam Workshop 服务

```csharp
public interface ISteamWorkshopService
{
    // 获取地图信息（从 Steam API）
    Task<MapHistoryEntry?> GetMapInfoAsync(string workshopId);
    
    // 下载预览图
    Task<string?> DownloadPreviewImageAsync(string previewUrl, string workshopId);
    
    // 解析 Workshop ID（支持 URL 和纯 ID）
    string? ParseWorkshopId(string url);
}
```

**特性**:
- 调用 Steam Web API: `ISteamRemoteStorage/GetPublishedFileDetails`
- 支持解析 URL: `https://steamcommunity.com/sharedfiles/filedetails/?id=123456`
- 支持纯数字 ID: `123456`
- 自动下载预览图到 `data/workshop_previews/`

#### **IMapHistoryService** - 地图历史服务

```csharp
public interface IMapHistoryService
{
    // 获取所有服务器的地图历史
    Task<List<MapHistoryEntry>> GetAllEntriesAsync();
    
    // 获取指定服务器的地图历史
    Task<List<MapHistoryEntry>> GetServerEntriesAsync(string serverId);
    
    // 记录地图加载（自动获取信息）
    Task RecordMapLoadAsync(string serverId, string workshopId);
    
    // 删除地图记录
    Task<bool> DeleteEntryAsync(string serverId, string workshopId);
    
    // 清空历史记录
    Task ClearServerHistoryAsync(string serverId);
}
```

**存储格式**: JSON
```json
{
  "server-id-1": [
    {
      "workshopId": "3070212191",
      "mapName": "de_dust2_rework",
      "authorId": "76561198012345678",
      "description": "Dust2 Rework Map",
      "firstLoadedAt": "2025-10-26T14:30:00",
      "lastLoadedAt": "2025-10-26T15:45:00",
      "loadCount": 5,
      "previewImagePath": "data/workshop_previews/preview_3070212191.jpg",
      "previewImageUrl": "https://steamuserimages-a.akamaihd.net/...",
      "fileSize": 12345678,
      "timeCreated": 1698765432,
      "timeUpdated": 1698876543
    }
  ]
}
```

### 13.4 数据模型

```csharp
public class MapHistoryEntry
{
    public string WorkshopId { get; set; }          // Workshop ID
    public string MapName { get; set; }             // 地图名称
    public string AuthorId { get; set; }            // 作者 Steam ID
    public string Description { get; set; }         // 地图描述
    public DateTime FirstLoadedAt { get; set; }     // 首次加载时间
    public DateTime LastLoadedAt { get; set; }      // 最后加载时间
    public int LoadCount { get; set; }              // 加载次数
    public string PreviewImagePath { get; set; }    // 预览图本地路径
    public string PreviewImageUrl { get; set; }     // 预览图 URL
    public long FileSize { get; set; }              // 文件大小
    
    // 计算属性
    public string WorkshopUrl => $"https://steamcommunity.com/sharedfiles/filedetails/?id={WorkshopId}";
    public bool HasPreviewImage => !string.IsNullOrEmpty(PreviewImagePath) && File.Exists(PreviewImagePath);
}
```

### 13.5 自动记录机制

**LogConsoleViewModel** 在发送命令时自动检测：

```csharp
private async Task TryRecordWorkshopMapAsync(string command)
{
    // 1. 检测命令是否为 host_workshop_map
    if (!command.Trim().ToLower().StartsWith("host_workshop_map"))
        return;
    
    // 2. 提取 Workshop ID 参数
    var workshopId = _workshopService.ParseWorkshopId(mapInput);
    
    // 3. 异步记录（不阻塞UI）
    _ = Task.Run(async () =>
    {
        await _mapHistoryService.RecordMapLoadAsync(serverId, workshopId);
    });
}
```

**触发场景**:
- 用户在日志控制台输入 `host_workshop_map 123456`
- 用户在日志控制台输入 `host_workshop_map https://steamcommunity.com/sharedfiles/filedetails/?id=123456`
- 通过快捷命令执行 `host_workshop_map`

### 13.6 UI 功能

#### **地图历史页面** (`MapHistoryView.xaml`)

**布局**:
```
┌──────────────────────────────────────────────────────────────┐
│  🗺️ Workshop 地图历史           [🔄 刷新] [🗑️ 清空历史]       │
├──────────────────────────────────────────────────────────────┤
│  共 12 个地图 • 48 次加载                                      │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ [预览图]  de_dust2_rework                               │ │
│  │           🆔 Workshop ID: 3070212191                    │ │
│  │           🕐 最后加载: 2025-10-26 15:45:00              │ │
│  │           📊 加载次数: 5                    [🌐 访问]   │ │
│  │                                            [🗑️ 删除]   │ │
│  └────────────────────────────────────────────────────────┘ │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ [预览图]  aim_map_pro                                   │ │
│  │           ...                                           │ │
│  └────────────────────────────────────────────────────────┘ │
│                                                              │
├──────────────────────────────────────────────────────────────┤
│  显示服务器 My Server 的地图历史                              │
└──────────────────────────────────────────────────────────────┘
```

**操作**:
- **访问 Workshop**: 打开浏览器跳转到地图的 Steam Workshop 页面
- **删除记录**: 删除地图历史记录和预览图
- **刷新列表**: 重新加载地图历史
- **清空历史**: 清空当前服务器或所有服务器的地图历史

#### **空状态提示**

当没有地图历史时：
```
        🗺️
  还没有加载过 Workshop 地图
  
  在服务器上使用 host_workshop_map <ID> 命令
  加载的地图将自动记录在这里
```

### 13.7 Steam API 集成

**API 端点**:
```
POST https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/?format=json

Body (Form Data):
  - itemcount: 1
  - publishedfileids[0]: <workshop_id>
```

**响应示例**:
```json
{
  "response": {
    "publishedfiledetails": [
      {
        "publishedfileid": "3070212191",
        "title": "de_dust2_rework",
        "creator": "76561198012345678",
        "description": "Dust2 Rework",
        "preview_url": "https://steamuserimages-a.akamaihd.net/.../preview.jpg",
        "file_size": "12345678",
        "time_created": 1698765432,
        "time_updated": 1698876543
      }
    ]
  }
}
```

**错误处理**:
- API 请求失败: 创建默认条目（使用 Workshop ID 作为名称）
- 预览图下载失败: 使用占位符图标
- 网络离线: 仍可查看已缓存的地图历史

### 13.8 性能优化

1. **异步处理**: 地图记录在后台线程执行，不阻塞UI
2. **预览图缓存**: 已下载的预览图不会重复下载
3. **延迟加载**: 地图历史页面打开时才加载数据
4. **文件锁机制**: 使用 `SemaphoreSlim` 防止并发写入冲突

### 13.9 与 cs2servergui 的对比

| 特性 | cs2servergui | CSP2 | 改进 |
|-----|-------------|------|------|
| **存储格式** | CSV (rapidcsv) | JSON | 更易扩展 |
| **多服务器** | 否 | 是 | 每服务器独立历史 |
| **URL 解析** | 是 | 是 | - |
| **预览图缓存** | 是 | 是 | - |
| **加载次数** | 否 | 是 | 统计功能增强 |
| **异步处理** | 部分 | 完全异步 | UI 更流畅 |
| **错误处理** | 基础 | 完善 | 离线可用 |

---

## 14. 日志控制台增强功能

**更新时间**: 2025-10-26

CSP2 从 cs2servergui 项目移植了多项实用功能，极大提升了命令行交互体验。

### 14.1 命令历史导航

**功能**: 使用 ↑↓ 箭头键浏览历史命令，类似 Linux Shell

**技术实现**:
```csharp
// CommandHistory.cs
public class CommandHistory
{
    public string? GetOlder();  // ↑ 键
    public string? GetNewer();  // ↓ 键
    public void Add(string command);
}
```

**特性**:
- 持久化到 `data/command_history.txt`
- 自动去重（连续相同命令不重复记录）
- 限制历史记录数量（默认 100 条）
- 光标自动移到末尾

**使用方法**:
1. 输入命令后按 Enter 发送
2. 按 ↑ 键查看上一条命令
3. 按 ↓ 键查看下一条命令

---

### 14.2 RCON 客户端支持

**功能**: 通过 RCON 协议远程管理服务器

**架构设计**:
```
IRCONClient (接口)
    ↓
RCONClient (实现 Source RCON 协议)
    ↓
LogConsoleViewModel (集成 RCON)
    ↓
UI (RCON 控制面板 + 配置对话框)
```

**RCON 协议** (Source Engine):
```
Packet = Size (4 bytes) + ID (4 bytes) + Type (4 bytes) + Body (N bytes) + Null (2 bytes)

Types:
- SERVERDATA_AUTH (3): 认证请求
- SERVERDATA_AUTH_RESPONSE (2): 认证响应
- SERVERDATA_EXECCOMMAND (2): 执行命令
- SERVERDATA_RESPONSE_VALUE (0): 命令响应
```

**特性**:
- ✅ Source RCON 协议完整实现
- ✅ 异步连接，不阻塞UI
- ✅ 认证和命令发送
- ✅ 连接状态可视化（绿色=已连接，灰色=未连接）
- ✅ 支持切换 RCON/stdin 模式
- ✅ RCON 响应显示在日志中
- ✅ **RCON 配置对话框** (新增)
- ✅ **连接测试功能** (新增)
- ✅ **智能重连机制** (新增)

**配置模型**:
```csharp
public class RCONConfig
{
    public bool Enabled { get; set; } = false;
    public string Host { get; set; } = "127.0.0.1";
    public int Port { get; set; } = 27015;
    public string Password { get; set; } = string.Empty;
    public int Timeout { get; set; } = 5000;
}
```

**RCON 配置对话框** (新增):
- 文件: `Views/Dialogs/RCONConfigDialog.xaml`
- 功能:
  - 🔧 配置 RCON 连接参数（地址、端口、密码、超时）
  - 🧪 测试连接功能（验证配置是否正确）
  - ℹ️ 内置使用指南和参数说明
  - ✅ 输入验证（端口范围、超时时间等）
  - 💾 保存到服务器配置

**使用场景**:
- **远程服务器管理**: 管理不在本机的服务器
- **更可靠的命令执行**: RCON 有明确的响应，stdin 可能丢失
- **调试远程服务器**: 无需本地启动服务器

**使用方法**:

**方式1: 通过配置对话框**
1. 点击日志控制台 RCON 区域的 **⚙️ 配置** 按钮
2. 填写 RCON 参数（地址、端口、密码、超时）
3. 点击 **测试连接** 验证配置（可选）
4. 勾选 **启用 RCON 连接**
5. 点击 **保存**
6. 系统自动连接（如果启用）

**方式2: 快速启用**
1. 确保服务器已配置 RCON 密码
2. 在日志控制台勾选 "启用 RCON"
3. 点击 "连接" 按钮
4. 发送命令自动通过 RCON
5. 可随时切换回 stdin 模式

**RCON vs stdin 对比**:
| 特性 | RCON | stdin |
|-----|------|-------|
| 远程访问 | ✅ | ❌ 仅本地 |
| 命令响应 | ✅ 有响应 | ❌ 无响应 |
| 配置复杂度 | 🟡 需要密码 | ✅ 无需配置 |
| 推荐场景 | 远程服务器 | 本地服务器 |

**详细文档**: 参见 `docs/RCON功能完善说明.md`

---

### 13.3 快捷命令 (Quick Commands)

**功能**: 保存常用命令为一键执行按钮

**数据模型**:
```csharp
// ServerConfig.cs
public List<string> QuickCommands { get; set; } = new();
```

**UI 设计**:
```
⚡ 快捷命令

[▶ mp_restartgame 1 ✕]  [▶ sv_cheats 1 ✕]  [▶ bot_kick all ✕]

[➕ 添加当前命令为快捷命令]
```

**特性**:
- ✅ 添加当前命令为快捷命令
- ✅ 一键执行快捷命令
- ✅ 删除快捷命令
- ✅ 自动保存到服务器配置
- ✅ 每个服务器独立的快捷命令列表

**使用方法**:
1. 在命令输入框输入常用命令（如 `mp_restartgame 1`）
2. 点击 "➕ 添加当前命令为快捷命令"
3. 快捷命令按钮出现在输入框下方
4. 点击 ▶ 按钮执行命令
5. 点击 ✕ 按钮删除命令

**典型快捷命令**:
- `mp_restartgame 1` - 重启回合
- `sv_cheats 1` - 启用作弊
- `bot_kick` - 踢出所有BOT
- `mp_warmup_end` - 结束热身
- `changelevel de_dust2` - 切换地图

---

### 13.4 功能对比

| 功能 | CSP2 (旧) | CSP2 (新) | cs2servergui |
|------|-----------|-----------|--------------|
| 命令发送 | ✅ stdin | ✅ stdin + RCON | ✅ RCON |
| 命令历史 | ❌ | ✅ ↑↓ 导航 | ✅ |
| 快捷命令 | ❌ | ✅ | ✅ |
| 日志查看 | ✅ | ✅ | ✅ |
| 日志导出 | ✅ | ✅ | ❌ |
| 多服务器 | ✅ | ✅ | 部分 |

---

### 13.5 未来计划

以下功能来自 cs2servergui，计划在后续版本实现：

**P1 优先级**:
- **Workshop 地图助手**: 专用输入框，支持地图 ID/URL，自动执行 `host_workshop_map`
- **多命令历史类型**: 不同输入框独立的历史记录（通用命令、地图、脚本）

**P2 优先级**:
- **地图历史记录**: 显示已加载的 Workshop 地图，带预览图
- **Steam API 集成**: 获取地图信息（名称、作者、描述）

---

## 15. 下一步

阅读完本文档后，请查看：
- `02-项目结构说明.md` - 了解代码组织方式
- `03-开发路线图.md` - 了解开发计划
- `04-WPF快速入门.md` - 学习WPF基础知识
- `05-i18n国际化使用指南.md` - 了解如何使用国际化功能
- `cs2servergui-feature-analysis.md` - cs2servergui 功能分析
- `cs2servergui-porting-summary.md` - 功能移植总结

---

**文档结束**

